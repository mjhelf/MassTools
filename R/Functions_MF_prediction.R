#' getSenior3
#'
#'  calculate the sum of valences minus twice (the number of atoms minus 1) (to check for Senior's third theorem, "Golden Rule #2")[1][2][3]
#'
#'
#' @references 
#' \enumerate{
#' \item Kind T, Fiehn O (2007) Seven Golden Rules for heuristic filtering of molecular formulas obtained by accurate mass spectrometry. BMC Bioinformatics 8:105. doi: 10.1186/1471-2105-8-105
#' \item Senior JK (1951) Partitions and Their Representative Graphs. Am J Math 73:663. doi: 10.2307/2372318
#' \item Morikawa T, Newbold BT (2003) Analogous odd-even parities in mathematics and chemistry. Chemistry 12:445–450
#'}
#' @param SF MFobject as generated by \code{\link{makeSF}}
#' @param vals maximum valences for a variety of elements
#'
getSenior3 <- function(SF, vals = c(C = 4, H = 1,
                                    Br = 1, Cl = 1,
                                    F = 1, N = 5,
                                    O = 2, P = 5,
                                    S = 6, Si = 4,
                                    Na = 1, K = 1,
                                    Mg = 2, Ca = 2)){
  
  vals <- vals[match(names(SF),names(vals))]
  
  #if result is >= 0, formula is valid as per Senior's third theorem 
  sum(SF*vals) - 2*(sum(SF)-1)
  
}


#' calcMF
#'
#' Calculate molecular formulas from a monoisotopic mass. This function uses \pkg{Rdisop} to generate molecular formulas, and can apply many of the filters described as the "seven golden rules"[1]
#' 
#' @references 
#' \enumerate{
#' \item Kind T, Fiehn O (2007) Seven Golden Rules for heuristic filtering of molecular formulas obtained by accurate mass spectrometry. BMC Bioinformatics 8:105. doi: 10.1186/1471-2105-8-105
#' \item Senior JK (1951) Partitions and Their Representative Graphs. Am J Math 73:663. doi: 10.2307/2372318
#' \item Morikawa T, Newbold BT (2003) Analogous odd-even parities in mathematics and chemistry. Chemistry 12:445–450
#'}
#'
#' @param mz monoisotopic mass or monoisotopic m/z value 
#' @param z charge (set 0 for uncharged)
#' @param ppm error tolerance in ppm
#' @param maxCounts check each predicted molecula formula for maximum number of elements expected in a natural product of its size ("Golden Rule #1")
#' @param SeniorRule for each predicted molecula formula, calculate the sum of valences minus twice (the number of atoms minus 1) (to check for Senior's third theorem, "Golden Rule #2")[1][2][3]
#' @param HCratio for each predicted molecula formula, calculate Hydrogen/ Carbon count ratio ("Golden Rule #4")
#' @param moreRatios for each predicted molecula formula, calculate Nitrogen/Carbon, Oxygen/Carbon, Phosphorus/Carbon and Sulfur/Carbon count ratios ("Golden Rule #5")
#' @param elementHeuristic apply a heuristic HNOPS probability check as proposed in "Golden Rule #6"
#' @param Filters which filters to apply, see Details
#' @param summarize if \code{TRUE}, will return a single character string with molecular formulas and charge instead of a data.table
#'
#' @details 
#' \subsection{Filters}{
#' These filtering steps can be selected. Filter items that are NULL (or not in the list) will not be applied.
#' 
#' \describe{
#'    \item{DBErange}{numeric vector of length 2, defining lower and upper limit for double bond equivalents in the molecule}
#'    \item{minElements}{character(1) with a molecula formula defining the minimum number of atom counts for a set of elements}
#'    \item{maxElements}{character(1) with a molecula formula defining the maximum number of atom counts for a set of elements}
#'    \item{parity}{filter for parity. must be \code{"e"} (for even) or \code{"o"} (for odd). What to expect depends on ionization technique used.}
#'    \item{maxCounts}{if \code{TRUE}, uses a filter limiting atom counts for elements as described by Kind & Fiehn [1]}
#'    \item{SENIOR3}{If \code{TRUE}, the sum of valences has to be greater than or equal to twice the number of atoms minus 1, as Senior's third theorem suggests [1][2][3]}
#'    \item{HCratio}{If \code{TRUE}, molecular formulas must have a Hydrogen/ Carbon count ratio of >0.2 and <3.1 ("Golden Rule #4")[1]. Will be ignored if no Hydrogen or Carbon present in a molecule.}
#'    \item{moreRatios}{If \code{TRUE}, molecular formulas must have these atom count ratios: Nitrogen/Carbon <1.3, Oxygen/Carbon <1.2, Phosphorus/Carbon <0.3 and Sulfur/Carbon <0.8 ("Golden Rule #5")[1]. Will be ignored if no Carbon present in a molecule.}
#'    \item{elementHeuristic}{If \code{TRUE}, additional element ratio heuristic is applied ("Golden Rule #6") [1]}
#' }}
#' 
#' @importFrom data.table rbindlist as.data.table data.table
#' @importFrom Rdisop decomposeMass
#' 
#' @export
calcMF <- function(mz = 200.000659,
                   z = 1,
                   ppm = 5,
                   elements = Rdisop::initializeCHNOPS(),
                   maxCounts = T,
                   SeniorRule = T,
                   HCratio = T,
                   moreRatios = T,
                   elementHeuristic = T,
                   Filters = list(DBErange = c(-5,40),
                                  minElements = "C0H0P0S0N0O0",
                                  maxElements = "C9999H9999P2S2N9999O9999",
                                  parity = "e",
                                  maxCounts = T,
                                  SENIOR3 = 0,
                                  HCratio = T,
                                  moreRatios = T,
                                  elementHeuristic = T),
                   summarize = F
){
  
  if(is.null(Filters$minElements) 
     ||(is.numeric(Filters$minElements) && !is.null(names(Filters$minElements)))){
    #do nothing
  } else if(is.character(Filters$minElements) && length(Filters$minElements) ==1){
    Filters$minElements <- makeSF(Filters$minElements)
  }else{simpleError("Filters$minElements format is not correct")}
  
  if(is.null(Filters$maxElements) 
     ||(is.numeric(Filters$maxElements) && !is.null(names(Filters$maxElements)))){
    #do nothing
  } else if(is.character(Filters$maxElements) && length(Filters$maxElements) ==1){
    Filters$maxElements <- makeSF(Filters$maxElements)
  }else{simpleError("Filters$maxElements format is not correct")}
  
  #how to handle it if there are no molecula formulas given filter conditions
  if(summarize){
    failReturn <- "" 
  }else{
    failReturn <- NULL
  }
  
  mm <- decomposeMass(mz, z = z, maxisotopes = 1, ppm = ppm, elements = elements)
  
  if(is.null(mm)){return(failReturn)}
  
  f1 <- if(!is.null(Filters$DBErange)){mm$DBE >= Filters$DBErange[1] & mm$DBE<= Filters$DBErange[2]}else{rep(TRUE,length(mm$DBE))}
  
  if(!is.null(Filters$parity) && Filters$parity %in% c('e','o')){
    f1 <- f1 & mm$parity == Filters$parity
  }
  
  if(!any(f1)){return(failReturn)}
  
  #"quick" check to see if any of the element requirements are met
  c3 <- if(!is.null(Filters$minElements) && any(Filters$minElements > 0)){
    apply(as.data.frame(lapply(names(Filters$minElements)[Filters$minElements!=0],grepl,mm$formula)),1,all)
  }else{TRUE}
  
  f1 <- which(f1 & c3)
  
  if(length(f1) == 0){return(failReturn)}
  
  #now reorder by mass difference
  f2 <- f1[order(abs(mm$exactmass[f1] - z*5.48579909070e-4 - mz))]
  
  res <- data.frame(mz = mm$exactmass[f2] - z*5.48579909070e-4,
                    MF = mm$formula[f2],
                    charge = z,
                    RdisopScore = mm$score[f2],
                    unsat = mm$DBE[f2],
                    parity = mm$parity[f2],
                    error = mm$exactmass[f2] - z*5.48579909070e-4 - mz,
                    nrule = mm$valid[f2],
                    stringsAsFactors = F)
  
  res$ppm <- res$error/mz *1e6
  #print(res)
  #final filter for elements:
  
  sfs <- lapply(res$MF, makeSF)
  
  ret <- sapply(sfs, function(sf){
    
    # 
    # vals <- vals[match(names(SF),names(vals))]
    # 
    # #if result is >= 0, formula is valid as per Senior's third theorem 
    # sum(SF*vals) - 2*(sum(SF)-1)
    # 
    
    
    all(sapply(names(sf),function(n){
      
      #note that is.na(Filters$minElements[n]) should be excluded already by the "quick" check method above
      ((is.null(Filters$maxElements) || is.na(Filters$maxElements[n]) || Filters$maxElements[n] >= sf[n]) 
       && (is.null(Filters$minElements) || (!is.na(Filters$minElements[n]) && Filters$minElements[n] <= sf[n])))
    }))
    
  })
  
  if(!any(ret)){return(failReturn)}
  
  #remove formulas not meeting min and max expectations
  res <- res[ret,]
  sfs <- sfs[ret]
  
  #Golden rule #1: Restriction for element numbers
  if(maxCounts){
    Da <- abs(mz/z)
    if(Da < 500){
      maxCountLimit <- c(C = 29,H = 72, N= 10, O = 18, P= 4, S= 7, F =15, Cl = 8, Br = 5)
    }else if(Da <1000){
      maxCountLimit <- c(C = 66,H = 126, N= 25, O = 27, P= 6, S= 8, F =16, Cl = 11, Br = 8)
    }else if(Da < 2000){
      maxCountLimit <- c(C = 115,H = 236, N= 32, O = 63, P= 6, S= 8, F =16, Cl = 11, Br = 8)
    }else if(Da < 3000){
      maxCountLimit <- c(C = 162,H = 208, N= 48, O = 78, P= 6, S= 9, F =16, Cl = 11, Br = 8)
    }else{
      maxCountLimit <- NULL
    }
    
    if(!is.null(maxCountLimit)){
      
      res$maxCounts <- sapply(sfs, function(sf){
        
        all(sapply(names(sf),function(n){
          
          (is.na(maxCountLimit[n]) || maxCountLimit[n] >= sf[n])
        }))
        
      })
      
      
    }else{
      res$maxCounts <- T
    }
    
    if(!is.null(Filters$maxCounts) && Filters$maxCounts){
      sel <- res$maxCounts
      if(!any(sel)){return(failReturn)}
      
      res <- res[sel,]
      sfs <- sfs[sel]
      
    }
    
  }
  
  #Golden rule #2: (Senior's third theorem): 
  
  if(SeniorRule){
    
    res$SENIOR3 <- sapply(sfs,getSenior3)
    
    if(!is.null(Filters$SENIOR3) && is.numeric(Filters$SENIOR3)){
      
      sel <- res$SENIOR3 >= Filters$SENIOR3
      if(!any(sel)){return(failReturn)}
      
      
      res <- res[sel,]
      sfs <- sfs[sel]
      
    }
    
  }
  
  
  #Golden Rule #4: Hydrogen/Carbon element ratio check
  if(HCratio){
    
    res$HtoC <-  sapply(sfs,function(SF){
      
      SF["H"]/SF["C"]
      
    })
    
    if(!is.null(Filters$HCratio) && Filters$HCratio){
      
      sel <- is.na(res$HtoC) | (res$HtoC > 0.2 & res$HtoC < 3.1)
      if(!any(sel)){return(failReturn)}
      
      res <- res[sel,]
      sfs <- sfs[sel]
      
    }
  }
  
  #Golden Rule #5: Heteroatom check
  if(moreRatios){
    
    ratios <-  rbindlist(c(list(starter = data.table(NtoC = double(0), OtoC = double(0), PtoC = double(0), StoC = double(0))),
                           results = lapply(sfs,function(SF){
                             
                             r1 <- na.omit(SF[c("N","O","P","S")]/SF["C"])
                             
                             if(length(r1) == 0){
                               return(data.table(NtoC = NA, OtoC = NA, PtoC = NA, StoC = NA)) 
                             }
                             
                             as.data.table(matrix(r1, nrow = 1, dimnames = list(rows = NULL, cols =  paste0(names(r1),"toC"))))
                             
                             #as.data.table(na.omit(SF[c("N","O","P","S")]/SF["C"]))
                             
                           })), fill = T)
    
    res <- as.data.frame(cbind(res,ratios), stringsAsFactors = F)
    
    if(!is.null(Filters$moreRatios) && Filters$moreRatios){
      
      sel <- ((is.na(res$NtoC) | res$NtoC < 1.3)
              & (is.na(res$OtoC) | res$OtoC < 1.2)
              & (is.na(res$PtoC) | res$PtoC < 0.3)
              & (is.na(res$StoC) | res$StoC < 0.8))
      
      if(!any(sel)){return(failReturn)}
      
      res <- res[sel,]
      sfs <- sfs[sel]
      
    }
    
  }
  
  # Golden rule #6: element probability check
  if(elementHeuristic){
    
    res$elementHeuristic = sapply(sfs,function(SF){
      
      r1 <- na.omit(SF[c("N","O","P","S")])
      
      r2 <- r1[r1>1]
      
      #if two of these elements are not in the molecule, don't apply restrictions
      if(length(r2) <= 2){return(T)}
      
      if(length(r2) == 4 
         && (r2["N"] >=10
             || r2["O"] >=20
             ||r2["P"] >=4
             ||r2["S"] >=3)){return(F)}
      
      switch(paste(names(r2), collapse = ""),
             NOP = {if(min(r2) > 3 && (r2["N"] >=11 || r2["O"] >=22 || r2["P"] >=7)){return(F)}},
             OPS = {if(min(r2) > 1 && (r2["S"] >=3 || r2["O"] >=14 || r2["P"] >=3)){return(F)}},                                                                            NPS = {if(min(r2) > 1 && (r2["N"] >=4 || r2["S"] >=3 || r2["P"] >=3)){return(F)}},
             NOS = {if(min(r2) > 6 && (r2["S"] >=8 || r2["O"] >=14 || r2["N"] >=19)){return(F)}})
      
      return(T)
      
      
    })
    
    
    if(!is.null(Filters$elementHeuristic) && Filters$elementHeuristic){
      
      sel <- res$elementHeuristic
      if(!any(sel)){return(failReturn)}
      
      res <- res[sel,]
      sfs <- sfs[sel]
      
    }
    
  }
  
  if(summarize){
    
    return(paste(paste0(res$MF,
                        if(res$charge[1] > 0){paste0("(+",res$charge,")")}
                        else if(res$charge[1] < 0){paste0("(",res$charge,")")}
                        else{""}),
                 collapse = "|"))
  }
  
  return(res)
}